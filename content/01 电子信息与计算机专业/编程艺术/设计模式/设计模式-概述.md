---
title: "设计模式的类别"
date: 2025-08-07
draft: false
---

	设计模式（Design Patterns）是一套被反复验证的、可重用的、解决常见软件设计问题的通用解决方案。它们为开发人员提供了一种简洁的方式，帮助处理系统架构中的设计挑战，提高代码的可读性、可维护性和可扩展性。

# 设计模式的类别

设计模式通常分为三大类：

1. **创建型模式（Creational Patterns）**：
   - 这些模式专注于如何有效地创建对象，并将对象创建过程与系统其他部分分离。
   - 主要模式：
     - **[[编程艺术/设计模式/单例模式]]（Singleton Pattern）**：确保一个类只有一个实例，并提供全局访问点。
     - **工厂模式（Factory Pattern）**：提供创建对象的接口，让子类决定要实例化的类。
     - **抽象工厂模式（Abstract Factory Pattern）**：提供一个用于创建相关或依赖对象的系列接口，而无需指定实际类。
     - **生成器模式（Builder Pattern）**：分离复杂对象的构建和表示，以便逐步创建对象。
     - **原型模式（Prototype Pattern）**：通过复制现有实例来创建新对象，而不是通过类继承。

2. **结构型模式（Structural Patterns）**：
   - 这些模式关注对象之间的组合，以形成更大的结构。
   - 主要模式：
     - **适配器模式（Adapter Pattern）**：将一个类的接口转换为客户端所期望的另一个接口。
     - **桥接模式（Bridge Pattern）**：将抽象部分与它的实现部分分离，使两者可以独立变化。
     - **组合模式（Composite Pattern）**：将对象组合成树状结构来表示“部分-整体”关系。
     - **装饰器模式（Decorator Pattern）**：动态地给对象添加功能。
     - **外观模式（Facade Pattern）**：为子系统提供一个简化的接口。
     - **享元模式（Flyweight Pattern）**：利用共享技术来有效地支持大量细粒度对象。
     - **代理模式（Proxy Pattern）**：为其他对象提供一个代理以控制对这个对象的访问。

3. **行为型模式（Behavioral Patterns）**：
   - 这些模式涉及对象间的通信，关注对象之间职责的分配和相互作用。
   - 主要模式：
     - **职责链模式（Chain of Responsibility Pattern）**：将请求沿着一个处理者链进行传递，直到被处理。
     - **命令模式（Command Pattern）**：将请求封装为对象，以便将不同的请求参数化。
     - **迭代器模式（Iterator Pattern）**：顺序访问集合对象中的元素，而不暴露集合的内部表示。
     - **中介者模式（Mediator Pattern）**：用一个中介对象来封装一组对象的交互。
     - **备忘录模式（Memento Pattern）**：保存对象状态，以便恢复。
     - **观察者模式（Observer Pattern）**：对象间一对多的依赖关系，当一个对象状态改变时通知其依赖者。
     - **状态模式（State Pattern）**：允许对象在内部状态改变时改变行为。
     - **策略模式（Strategy Pattern）**：定义一系列算法，将它们封装起来并可以互换使用。
     - **模板方法模式（Template Method Pattern）**：在父类中定义算法结构，而将一些步骤留给子类实现。
     - **访问者模式（Visitor Pattern）**：在不改变数据结构的前提下增加新的操作。



**2. 每种模式的定义和使用场景**


# SOLID原则
• **单一职责**原则（Single Responsibility Principle，**S**RP）：每个类应该只有一个引起其变化的原因。
• **开闭**原则（Open/Closed Principle，**O**CP）：软件实体应对扩展开放，对修改关闭。
• **里氏替换**原则（Liskov Substitution Principle，**L**SP）：子类应该能够替换父类而不影响程序运行。
• **接口隔离**原则（Interface Segregation Principle，**I**SP）：应当为不同的客户端定义不同的接口，而不是一个通用的接口。
• **依赖倒置**原则（Dependency Inversion Principle，**D**IP）：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。

  

**4. 设计模式的优缺点**

  

每种设计模式都有其适用场景和局限性。学习时应关注以下几个方面：

  

• **优点**：是否提高了代码的可读性、可维护性、可扩展性？

• **缺点**：是否增加了系统的复杂性？是否导致了过度设计？

  

## 设计模式之间的比较

• **工厂方法模式** vs **抽象工厂模式**：前者用于创建单个产品，后者用于创建一族相关产品。

• **适配器模式** vs **桥接模式**：适配器模式用于兼容现有接口，桥接模式用于分离抽象部分和具体实现部分。

  

**6. 设计模式的实现与代码示例**

  

理解每种模式的代码实现和具体应用场景非常重要。例如，理解如何使用 Python、Java 或 C++ 实现这些模式，以及代码中的关键要素。

  

# 反模式（Anti-Patterns）
学习设计模式时，也需要了解一些常见的反模式，即那些看似解决问题但会带来更大问题的设计方法。反模式包括：

  

• 大泥球（Big Ball of Mud）

• 神对象（God Object）

• 单例滥用（Singleton Overuse）

  

**8. 面向对象设计中的设计模式应用**

  

如何将设计模式应用于实际的面向对象编程（OOP）中，比如在构建系统时选择合适的模式来解决问题。

  

**9. 设计模式的演进**

  

在实际项目中，如何根据项目的变化灵活调整模式的使用，比如从简单的工厂方法演进到更复杂的抽象工厂模式。

# 价值

- **提供标准术语**：设计模式有助于团队间的沟通和交流。
- **重用设计解决方案**：模式为常见问题提供预先定义的解决方案。
- **提高代码质量**：通过遵循这些设计原则，代码更容易维护、扩展和复用。

理解并应用设计模式能有效提高软件开发的质量和效率。