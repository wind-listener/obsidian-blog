---
aliases:
  - attention
---
**Self-attention** 和 **cross-attention** 是 Transformer 模型中的两个重要概念，它们都用于计算序列中不同位置之间的依赖关系。虽然这两者有相似之处，但它们的应用场景和机制是不同的。

  

**1. Self-attention（自注意力）**

  

自注意力机制允许模型在处理某个输入时，考虑到该输入序列中所有其他位置的信息。简而言之，它使得每个元素能够与序列中的其他元素互动，从而获取上下文信息。

  

**自注意力的计算步骤**

  

对于一个输入序列中的每个位置（例如，一个单词或图像块），自注意力机制会计算它与其他所有位置之间的**注意力权重**，然后通过这些权重加权输入序列的每个元素，从而得到该位置的上下文表示。

• **输入**：假设我们有一个输入序列 ，每个 是一个向量，表示序列中的一个元素（如单词或图像块）。

• **Q、K、V**：对于每个元素，我们会通过线性变换得到三个向量：

• **Query (Q)**：查询向量，表示该位置要获取哪些信息。

• **Key (K)**：键向量，表示每个位置提供的信息。

• **Value (V)**：值向量，表示每个位置的实际信息。

• **注意力权重**：通过计算每个元素的 Query 与所有其他元素的 Key 的点积，得到注意力分数。这个分数衡量了每个位置对其他位置的关注程度。

其中， 是 Key 向量的维度， 是为了防止点积结果过大导致梯度消失。

• **输出**：每个元素的最终表示是通过加权平均所有位置的 Value 向量得到的。

  

**作用**

• **捕捉全局依赖**：自注意力能够捕捉到输入序列中不同位置之间的依赖关系，这对于自然语言处理和计算机视觉任务非常重要。

• **并行化**：与循环神经网络（RNN）不同，自注意力机制允许并行计算，因为它不依赖于序列的顺序。

  

**示例**

  

在一个句子中，对于“猫”这个词的表示，模型可能需要关注句子中的其他词（如“吃”或“鱼”）来理解“猫吃鱼”这个动作。因此，“猫”的表示会是“猫”和整个句子上下文的加权组合。

**2. Cross-attention（交叉注意力）**

  

交叉注意力是在两个不同的输入序列之间计算注意力，它通常出现在多模态任务中（例如，图像-文本任务），或者在一些高级Transformer架构中（如Encoder-Decoder结构）用于将两个序列的上下文信息相结合。

  

**交叉注意力的计算步骤**

  

在交叉注意力中，一个序列（通常是“查询序列”）通过 **Query** 向另一个序列（通常是“键和值序列”）寻求信息。具体步骤如下：

• **输入**：有两个序列，一个是查询序列（Query Sequence），另一个是键值序列（Key-Value Sequence）。

• 查询序列的每个元素都有对应的 **Query** 向量。

• 键值序列的每个元素都有对应的 **Key** 和 **Value** 向量。

• **计算注意力**：查询序列的每个 Query 向量与键值序列的所有 Key 向量进行点积，计算注意力权重。

• **输出**：查询序列的每个元素都会得到加权后的 Value 向量，最终通过加权平均生成新的表示。

  

**作用**

• **跨模态信息交互**：交叉注意力常用于需要从一个模态（如图像）中获取与另一个模态（如文本）相关的信息的任务。例如，在图像字幕生成（image captioning）任务中，图像的特征可以通过交叉注意力机制与文本的特征交互，以生成适当的字幕。

• **Encoder-Decoder 架构**：在标准的Encoder-Decoder架构（如机器翻译）中，交叉注意力用于Decoder部分，帮助Decoder从Encoder生成的编码信息中提取重要的上下文。

  

**示例**

  

在图像-文本任务中，假设我们有一张图片和一段描述文字，交叉注意力机制可以帮助模型从文字描述中提取与图片内容相关的信息，反之亦然。例如，模型在生成图片描述时，可以利用图片中的特征来选择适合的词汇。

**区别总结**

• **Self-attention（自注意力）**：在同一个序列内部进行信息交互，每个元素根据自己和序列中其他元素的关系来更新自己的表示。

• **Cross-attention（交叉注意力）**：在两个不同的序列之间进行信息交互，查询序列通过其 Query 向另一个序列的 Key 和 Value 寻求信息。通常出现在多模态任务或者Encoder-Decoder结构中。

  

这两者都属于注意力机制，但应用场景和计算对象不同。

除了 **Self-attention** 和 **Cross-attention**，在深度学习中还有一些其他常见的注意力机制，每种机制都有不同的应用场景和特点。以下是一些常见的注意力机制：

  

# ** Scaled Dot-Product Attention (缩放点积注意力)**

  

这是 Transformer 模型中最基本的注意力机制，也是 **Self-attention** 和 **Cross-attention** 的核心计算方式。通过对 Query 和 Key 进行点积计算并进行缩放来获得注意力权重。

公式：

$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V
$$


• 其中， 是查询向量， 是键向量， 是值向量， 是键向量的维度。

  

# ** Multi-Head Attention (多头注意力)**

  

**多头注意力**机制将多个注意力机制并行化，每个注意力头使用不同的参数来处理信息。这样做可以捕捉到不同子空间的关系，使得模型能够从多个角度关注输入的不同部分。

• **思想**：将输入的查询、键和值分成多个子空间（即多个头），分别进行缩放点积注意力计算，最后将每个头的输出拼接起来，经过线性变换得到最终的结果。

• **优势**：多头注意力可以在不同的表示空间中捕捉信息，增强模型的表达能力。

  

**3. Additive Attention (加性注意力)**

  

加性注意力是一种计算注意力权重的方式，其中 Query 和 Key 不是直接通过点积计算的，而是通过一个具有可学习参数的前馈神经网络来计算权重。

  

公式：

```
\text{Attention}(Q, K, V) = \text{softmax}(f(Q, K)) V
```

• 其中， 是一个神经网络函数，通常包括一个具有可学习权重的仿射变换。

  

加性注意力在计算上比点积注意力更加灵活，但也更复杂。它通常出现在 **Bahdanau Attention** 这种基于RNN的模型中，特别是在机器翻译任务中。

  

**4. Bahdanau Attention (Bahdanau 注意力)**

  

Bahdanau注意力是一种用于机器翻译的加性注意力机制，它解决了传统编码器-解码器架构中的信息瓶颈问题。

• **特点**：该机制基于RNN的模型，它通过计算当前解码器状态和所有编码器状态的加性权重来进行对齐。然后，用这些权重来加权编码器的输出，生成解码器的输入。

  

**5. Luong Attention (Luong 注意力)**

  

Luong注意力是一种用于机器翻译任务的加性注意力机制。与Bahdanau Attention类似，Luong Attention使用点积或加法计算注意力权重，但它的计算方式更简单，通常被用于基于RNN的模型中。

• **区别**：Luong注意力在计算权重时，Query和Key直接进行点积（**dot-product**）或者加性（**general**）计算，这与Bahdanau Attention的结构略有不同。

  

**6. Hard Attention (硬注意力)**

  

**硬注意力**不同于其他注意力机制，它的核心思想是通过选择性地聚焦于图像或文本的某个部分来进行信息提取，而不是对所有输入都进行加权。

• **特点**：硬注意力是一个离散的选择过程，通常需要使用强化学习或蒙特卡洛方法进行训练，因为它不是连续可导的。

• **应用**：硬注意力常用于图像标注、视觉问答等任务，在这些任务中，模型需要选择图像中的某一部分进行处理。

  

**7. Soft Attention (软注意力)**

  

**软注意力**是一个连续的选择过程，通过为每个输入元素分配一个权重来加权输入。这种机制是可微分的，可以通过标准的梯度下降方法进行训练。

• **特点**：软注意力通常比硬注意力容易训练，因为它是连续的，可以直接通过反向传播来更新模型参数。

• **应用**：软注意力广泛应用于神经机器翻译、图像描述生成等任务。

  

**8. Global Attention (全局注意力)**

  

全局注意力是指，在计算注意力时，查询向量会与所有的键向量进行交互。每个查询都与所有的键进行比较，并且每个键都会为每个查询贡献一个注意力值。

• **应用**：这种注意力机制在Transformer架构中被广泛使用，尤其是当输入序列的长度不是特别长时，全局注意力能够捕捉到所有元素之间的依赖关系。

  

**9. Local Attention (局部注意力)**

  

局部注意力只计算输入序列中某个局部区域内的注意力。通过限制计算的范围，可以减少计算的复杂度，尤其是在处理长序列时非常有效。

• **应用**：局部注意力常用于图像处理和长序列任务，尤其是当输入序列非常长时，通过将注意力限制在局部区域内可以有效提高效率。

  

**10. Sparse Attention (稀疏注意力)**

  

稀疏注意力机制是在传统注意力机制的基础上，减少了计算量。它通过在注意力计算中只选择一部分重要的键值对来计算注意力，从而减少了计算开销。

• **应用**：稀疏注意力特别适合处理非常长的序列，比如在一些大规模预训练模型中（例如长文本生成）会使用这种方法。

  

**11. Linformer Attention**

  

Linformer 是一种针对长序列的高效注意力机制，它通过低秩近似来减少注意力计算的复杂度。它的关键思想是，输入的每个序列位置只需要与一个小范围的窗口内的位置进行注意力计算，从而极大地减少了计算量。

• **应用**：Linformer 主要用于处理长序列数据，尤其是在 NLP 任务中，能够显著提高计算效率。

**总结**

  

这些注意力机制提供了不同的方式来捕捉输入数据中的重要信息，根据任务的需要，选择适合的注意力机制可以有效提升模型的表现。在实践中，通常会结合 **Self-attention**、**Multi-head Attention** 等机制来提升模型的性能，而像 **Hard Attention** 和 **Sparse Attention** 则更多应用于特定任务或用于提高计算效率。


# 相关链接
[一文看尽深度学习中的各种注意力机制（1998-2020年）](https://blog.csdn.net/amusi1994/article/details/118347925)